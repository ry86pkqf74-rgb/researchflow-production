/**
 * Watermark Service (Task 63)
 *
 * Embeds invisible watermarks in AI-generated content for provenance tracking.
 * Supports multiple watermarking strategies for different content types.
 *
 * Strategies:
 * - JSON: Adds metadata fields
 * - Text: Adds configurable attribution footer
 * - Steganographic: Embeds watermark in whitespace (future)
 */

import { createHash, createHmac, randomBytes } from 'crypto';

/**
 * Watermark metadata embedded in content
 */
export interface WatermarkMetadata {
  invocationId: string;
  timestamp: number;
  modelId: string;
  userId?: string;
  version: string;
  signature?: string;
}

/**
 * Watermark configuration
 */
export interface WatermarkConfig {
  enabled: boolean;
  secretKey: string;
  version: string;
  attribution: string;
  includeTimestamp: boolean;
  includeModel: boolean;
}

/**
 * Watermark verification result
 */
export interface WatermarkVerification {
  verified: boolean;
  metadata?: WatermarkMetadata;
  error?: string;
  confidence: number;
}

/**
 * Default watermark configuration
 */
const DEFAULT_CONFIG: WatermarkConfig = {
  enabled: process.env.WATERMARK_AI_OUTPUT === 'true',
  secretKey: process.env.WATERMARK_SECRET_KEY || 'researchflow-default-key-change-in-production',
  version: '1.0.0',
  attribution: 'Generated by ResearchFlow AI',
  includeTimestamp: true,
  includeModel: true,
};

/**
 * Watermark Service
 */
export class WatermarkService {
  private config: WatermarkConfig;

  constructor(config?: Partial<WatermarkConfig>) {
    this.config = { ...DEFAULT_CONFIG, ...config };
  }

  /**
   * Generate signature for watermark metadata
   */
  private generateSignature(metadata: Omit<WatermarkMetadata, 'signature'>): string {
    const data = JSON.stringify({
      invocationId: metadata.invocationId,
      timestamp: metadata.timestamp,
      modelId: metadata.modelId,
      userId: metadata.userId,
      version: metadata.version,
    });

    return createHmac('sha256', this.config.secretKey)
      .update(data)
      .digest('hex')
      .substring(0, 16); // Shortened for embedding
  }

  /**
   * Verify signature for watermark metadata
   */
  private verifySignature(metadata: WatermarkMetadata): boolean {
    if (!metadata.signature) return false;

    const expectedSignature = this.generateSignature(metadata);
    return metadata.signature === expectedSignature;
  }

  /**
   * Embed watermark in JSON content
   */
  embedInJson(content: Record<string, unknown>, metadata: Omit<WatermarkMetadata, 'signature' | 'version'>): Record<string, unknown> {
    if (!this.config.enabled) {
      return content;
    }

    const fullMetadata: WatermarkMetadata = {
      ...metadata,
      version: this.config.version,
    };

    fullMetadata.signature = this.generateSignature(fullMetadata);

    return {
      ...content,
      _rf_watermark: {
        aiGenerated: true,
        generator: 'ResearchFlow',
        model: this.config.includeModel ? metadata.modelId : undefined,
        timestamp: this.config.includeTimestamp ? new Date(metadata.timestamp).toISOString() : undefined,
        version: this.config.version,
        signature: fullMetadata.signature,
        invocationId: metadata.invocationId,
      },
    };
  }

  /**
   * Embed watermark in text content
   */
  embedInText(content: string, metadata: Omit<WatermarkMetadata, 'signature' | 'version'>): string {
    if (!this.config.enabled) {
      return content;
    }

    const fullMetadata: WatermarkMetadata = {
      ...metadata,
      version: this.config.version,
    };

    fullMetadata.signature = this.generateSignature(fullMetadata);

    // Build attribution footer
    const parts: string[] = [];
    parts.push(this.config.attribution);

    if (this.config.includeModel) {
      parts.push(`Model: ${metadata.modelId}`);
    }

    if (this.config.includeTimestamp) {
      parts.push(`Generated: ${new Date(metadata.timestamp).toISOString()}`);
    }

    // Add verification code (shortened signature)
    parts.push(`Verification: ${fullMetadata.signature.substring(0, 8)}`);

    const footer = `\n\n---\n${parts.join(' | ')}`;

    return content + footer;
  }

  /**
   * Embed watermark in any content (auto-detect type)
   */
  embed(content: string | Record<string, unknown>, metadata: Omit<WatermarkMetadata, 'signature' | 'version'>): string | Record<string, unknown> {
    if (!this.config.enabled) {
      return content;
    }

    if (typeof content === 'object' && content !== null) {
      return this.embedInJson(content, metadata);
    }

    // Try to parse as JSON
    if (typeof content === 'string') {
      try {
        const parsed = JSON.parse(content);
        if (typeof parsed === 'object' && parsed !== null) {
          const watermarked = this.embedInJson(parsed, metadata);
          return JSON.stringify(watermarked, null, 2);
        }
      } catch {
        // Not JSON, treat as text
      }
      return this.embedInText(content, metadata);
    }

    return content;
  }

  /**
   * Extract watermark from JSON content
   */
  extractFromJson(content: Record<string, unknown>): WatermarkMetadata | null {
    const watermark = content._rf_watermark as Record<string, unknown> | undefined;

    if (!watermark) {
      return null;
    }

    return {
      invocationId: watermark.invocationId as string,
      timestamp: watermark.timestamp ? new Date(watermark.timestamp as string).getTime() : 0,
      modelId: watermark.model as string || 'unknown',
      version: watermark.version as string || '1.0.0',
      signature: watermark.signature as string,
    };
  }

  /**
   * Extract watermark from text content
   */
  extractFromText(content: string): WatermarkMetadata | null {
    // Look for attribution footer
    const footerMatch = content.match(/\n\n---\n(.+)$/);
    if (!footerMatch) {
      return null;
    }

    const footer = footerMatch[1];
    const parts = footer.split(' | ');

    // Parse parts
    let modelId = 'unknown';
    let timestamp = 0;
    let signature = '';

    for (const part of parts) {
      if (part.startsWith('Model: ')) {
        modelId = part.substring(7);
      } else if (part.startsWith('Generated: ')) {
        timestamp = new Date(part.substring(11)).getTime();
      } else if (part.startsWith('Verification: ')) {
        signature = part.substring(14);
      }
    }

    // We can't fully recover invocationId from text watermark
    // Return partial metadata
    return {
      invocationId: 'unknown-from-text',
      timestamp,
      modelId,
      version: this.config.version,
      signature,
    };
  }

  /**
   * Extract watermark from any content (auto-detect type)
   */
  extract(content: string | Record<string, unknown>): WatermarkMetadata | null {
    if (typeof content === 'object' && content !== null) {
      return this.extractFromJson(content);
    }

    if (typeof content === 'string') {
      // Try JSON first
      try {
        const parsed = JSON.parse(content);
        if (typeof parsed === 'object' && parsed !== null) {
          return this.extractFromJson(parsed);
        }
      } catch {
        // Not JSON, try text extraction
      }
      return this.extractFromText(content);
    }

    return null;
  }

  /**
   * Verify watermark authenticity
   */
  verify(content: string | Record<string, unknown>): WatermarkVerification {
    const metadata = this.extract(content);

    if (!metadata) {
      return {
        verified: false,
        error: 'No watermark found',
        confidence: 0,
      };
    }

    // For text-extracted watermarks, we can only partially verify
    if (metadata.invocationId === 'unknown-from-text') {
      return {
        verified: false,
        metadata,
        error: 'Text watermark cannot be fully verified (partial data)',
        confidence: 0.5,
      };
    }

    // Full verification for JSON watermarks
    const isValid = this.verifySignature(metadata);

    return {
      verified: isValid,
      metadata,
      error: isValid ? undefined : 'Signature verification failed',
      confidence: isValid ? 1.0 : 0,
    };
  }

  /**
   * Remove watermark from content (for comparison/processing)
   */
  remove(content: string | Record<string, unknown>): string | Record<string, unknown> {
    if (typeof content === 'object' && content !== null) {
      const { _rf_watermark, ...rest } = content as Record<string, unknown> & { _rf_watermark?: unknown };
      return rest;
    }

    if (typeof content === 'string') {
      // Try JSON first
      try {
        const parsed = JSON.parse(content);
        if (typeof parsed === 'object' && parsed !== null) {
          const { _rf_watermark, ...rest } = parsed;
          return JSON.stringify(rest, null, 2);
        }
      } catch {
        // Not JSON
      }

      // Remove text footer
      return content.replace(/\n\n---\n.+$/, '');
    }

    return content;
  }

  /**
   * Check if content has a watermark
   */
  hasWatermark(content: string | Record<string, unknown>): boolean {
    return this.extract(content) !== null;
  }

  /**
   * Check if watermarking is enabled
   */
  isEnabled(): boolean {
    return this.config.enabled;
  }

  /**
   * Update configuration
   */
  configure(config: Partial<WatermarkConfig>): void {
    this.config = { ...this.config, ...config };
  }
}

/**
 * Singleton instance
 */
let defaultWatermarkService: WatermarkService | null = null;

export function getWatermarkService(config?: Partial<WatermarkConfig>): WatermarkService {
  if (!defaultWatermarkService || config) {
    defaultWatermarkService = new WatermarkService(config);
  }
  return defaultWatermarkService;
}

/**
 * Check if watermarking is enabled
 */
export function isWatermarkingEnabled(): boolean {
  return process.env.WATERMARK_AI_OUTPUT === 'true';
}
