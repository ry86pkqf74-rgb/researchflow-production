"""
Stage 15: Artifact Bundling

Handles artifact packaging for sharing and archiving including:
- Artifact selection and validation
- PHI status verification before bundling
- Bundle format generation (zip, tar.gz)
- Dublin Core metadata manifest generation
"""

import hashlib
import json
import logging
import os
import uuid
from datetime import datetime
from typing import Any, Dict, List, Optional

from ..types import StageContext, StageResult
from ..registry import register_stage

logger = logging.getLogger("workflow_engine.stages.stage_15_bundling")

# Supported bundle formats
SUPPORTED_FORMATS = {"zip", "tar.gz", "tar"}

# Dublin Core metadata fields
DUBLIN_CORE_FIELDS = [
    "title",
    "creator",
    "subject",
    "description",
    "publisher",
    "contributor",
    "date",
    "type",
    "format",
    "identifier",
    "source",
    "language",
    "relation",
    "coverage",
    "rights",
]


def generate_bundle_id() -> str:
    """Generate a unique bundle identifier.

    Returns:
        UUID-based bundle identifier
    """
    return f"bundle-{uuid.uuid4().hex[:12]}"


def compute_artifact_checksum(artifact_path: str) -> Optional[str]:
    """Compute SHA256 checksum of an artifact file.

    Args:
        artifact_path: Path to the artifact file

    Returns:
        SHA256 hex digest or None if file cannot be read
    """
    if not os.path.exists(artifact_path):
        return None

    sha256 = hashlib.sha256()
    try:
        with open(artifact_path, "rb") as f:
            for chunk in iter(lambda: f.read(8192), b""):
                sha256.update(chunk)
        return sha256.hexdigest()
    except Exception:
        return None


def generate_dublin_core_manifest(
    bundle_id: str,
    artifacts: List[Dict[str, Any]],
    context: StageContext,
) -> Dict[str, Any]:
    """Generate Dublin Core compliant metadata manifest.

    Args:
        bundle_id: Unique bundle identifier
        artifacts: List of artifact metadata dictionaries
        context: Stage execution context

    Returns:
        Dublin Core formatted manifest dictionary
    """
    config = context.config
    now = datetime.utcnow().isoformat() + "Z"

    manifest = {
        "dc:identifier": bundle_id,
        "dc:title": config.get("bundle_title", f"Research Bundle {bundle_id}"),
        "dc:creator": config.get("creator", "ResearchFlow System"),
        "dc:date": now,
        "dc:type": "Dataset",
        "dc:format": config.get("bundle_format", "zip"),
        "dc:language": config.get("language", "en"),
        "dc:rights": config.get("rights", "All rights reserved"),
        "dc:description": config.get(
            "description",
            "Research artifacts bundle generated by ResearchFlow"
        ),
        "bundle_metadata": {
            "version": "1.0",
            "generated_at": now,
            "job_id": context.job_id,
            "governance_mode": context.governance_mode,
            "artifact_count": len(artifacts),
            "artifacts": artifacts,
        },
    }

    # Add optional Dublin Core fields if provided
    for field in DUBLIN_CORE_FIELDS:
        dc_key = f"dc:{field}"
        if field in config and dc_key not in manifest:
            manifest[dc_key] = config[field]

    return manifest


def validate_phi_status(
    context: StageContext,
    artifact_selection: List[str],
) -> tuple[bool, str, Dict[str, str]]:
    """Validate PHI status of selected artifacts before bundling.

    Args:
        context: Stage execution context
        artifact_selection: List of artifact paths to validate

    Returns:
        Tuple of (is_safe, status_message, artifact_phi_status)
    """
    # Check PHI detection results from stage 5
    phi_result = context.previous_results.get(5)
    artifact_phi_status: Dict[str, str] = {}

    if phi_result is None:
        # No PHI scan performed - flag as unknown
        for artifact in artifact_selection:
            artifact_phi_status[artifact] = "unknown"
        return False, "PHI scan (stage 5) not completed", artifact_phi_status

    phi_output = phi_result.output or {}
    phi_detected = phi_output.get("phi_detected", False)
    risk_level = phi_output.get("risk_level", "unknown")

    # Mark all artifacts based on PHI scan results
    for artifact in artifact_selection:
        if phi_detected:
            artifact_phi_status[artifact] = f"phi_detected_{risk_level}"
        else:
            artifact_phi_status[artifact] = "cleared"

    # Determine if safe to bundle
    if context.governance_mode == "PRODUCTION":
        if risk_level in ("medium", "high"):
            return (
                False,
                f"Cannot bundle in PRODUCTION mode with {risk_level} PHI risk",
                artifact_phi_status,
            )
    elif context.governance_mode == "STAGING":
        if risk_level == "high":
            return (
                False,
                "Cannot bundle in STAGING mode with high PHI risk",
                artifact_phi_status,
            )

    status_msg = "cleared" if not phi_detected else f"phi_risk_{risk_level}"
    return True, status_msg, artifact_phi_status


@register_stage
class ArtifactBundlingStage:
    """Stage 15: Artifact Bundling

    Packages selected artifacts for sharing or archiving with proper
    metadata manifests and PHI status validation.
    """

    stage_id = 15
    stage_name = "Artifact Bundling"

    async def execute(self, context: StageContext) -> StageResult:
        """Execute artifact bundling.

        Args:
            context: Stage execution context

        Returns:
            StageResult with bundle path, manifest, and PHI status
        """
        started_at = datetime.utcnow().isoformat() + "Z"
        errors: List[str] = []
        warnings: List[str] = []
        artifacts: List[str] = []
        output: Dict[str, Any] = {}

        logger.info(f"Starting artifact bundling for job {context.job_id}")

        # Get bundling configuration
        config = context.config
        artifact_selection = config.get("artifact_selection", [])
        bundle_format = config.get("bundle_format", "zip")

        # Validate bundle format
        if bundle_format not in SUPPORTED_FORMATS:
            errors.append(
                f"Unsupported bundle format '{bundle_format}'. "
                f"Supported: {sorted(SUPPORTED_FORMATS)}"
            )

        # Validate artifact selection
        if not artifact_selection:
            # Default to all artifacts from previous stages
            for stage_id, result in context.previous_results.items():
                if result.artifacts:
                    artifact_selection.extend(result.artifacts)

            if not artifact_selection:
                warnings.append("No artifacts selected for bundling")

        # Validate PHI status before bundling
        phi_safe, phi_status, artifact_phi_status = validate_phi_status(
            context, artifact_selection
        )

        if not phi_safe:
            errors.append(f"PHI validation failed: {phi_status}")

        output["phi_status"] = {
            "safe_to_bundle": phi_safe,
            "status": phi_status,
            "artifact_status": artifact_phi_status,
        }

        # Generate bundle if no errors
        bundle_id = generate_bundle_id()
        bundle_path = None

        if not errors:
            # Collect artifact metadata
            artifact_metadata: List[Dict[str, Any]] = []
            total_size = 0

            for artifact_path in artifact_selection:
                checksum = compute_artifact_checksum(artifact_path)
                if os.path.exists(artifact_path):
                    size = os.path.getsize(artifact_path)
                    total_size += size
                    artifact_metadata.append({
                        "path": artifact_path,
                        "filename": os.path.basename(artifact_path),
                        "size_bytes": size,
                        "checksum_sha256": checksum,
                        "phi_status": artifact_phi_status.get(artifact_path, "unknown"),
                    })
                else:
                    warnings.append(f"Artifact not found: {artifact_path}")

            # Generate Dublin Core manifest
            manifest = generate_dublin_core_manifest(
                bundle_id, artifact_metadata, context
            )

            # Determine bundle output path
            bundle_filename = f"{bundle_id}.{bundle_format}"
            bundle_path = os.path.join(context.artifact_path, bundle_filename)

            output["bundle_id"] = bundle_id
            output["bundle_path"] = bundle_path
            output["bundle_format"] = bundle_format
            output["manifest"] = manifest
            output["artifact_count"] = len(artifact_metadata)
            output["total_size_bytes"] = total_size

            # Note: Actual bundle creation would happen here
            # For now, we prepare the manifest and metadata
            logger.info(
                f"Bundle prepared: {bundle_id} with {len(artifact_metadata)} artifacts"
            )

            # Store manifest as artifact
            manifest_path = os.path.join(
                context.artifact_path, f"{bundle_id}_manifest.json"
            )
            try:
                os.makedirs(os.path.dirname(manifest_path), exist_ok=True)
                with open(manifest_path, "w", encoding="utf-8") as f:
                    json.dump(manifest, f, indent=2)
                artifacts.append(manifest_path)
                logger.info(f"Manifest written to {manifest_path}")
            except Exception as e:
                warnings.append(f"Failed to write manifest: {str(e)}")

        completed_at = datetime.utcnow().isoformat() + "Z"
        started_dt = datetime.fromisoformat(started_at.replace("Z", "+00:00"))
        completed_dt = datetime.fromisoformat(completed_at.replace("Z", "+00:00"))
        duration_ms = int((completed_dt - started_dt).total_seconds() * 1000)

        status = "failed" if errors else "completed"

        return StageResult(
            stage_id=self.stage_id,
            stage_name=self.stage_name,
            status=status,
            started_at=started_at,
            completed_at=completed_at,
            duration_ms=duration_ms,
            output=output,
            artifacts=artifacts,
            errors=errors,
            warnings=warnings,
            metadata={
                "governance_mode": context.governance_mode,
                "bundle_format": bundle_format,
                "artifact_selection_count": len(artifact_selection),
            },
        )
